<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高阶组件</title>
      <link href="undefined2019/09/04/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
      <url>2019/09/04/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p><strong>高阶组件是参数为组件，并且返回新组件的函数</strong></p><p><code>hocFactory:: W: React.Component =&gt; E: React.Component</code></p><p>其实现方式上基本上是一个类工厂</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><blockquote><ul><li>属性代理</li><li>反向继承</li></ul></blockquote><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><pre><code class="jsx">const HOC = WrapperCom =&gt; class extends React.Component {  state = {}  render() {    // 在此处过滤不必要的props     // 添加新的props属性    return &lt;WrapperCom {...this.props} /&gt;  }}function Component1() {  return (    &lt;div&gt;      Component1    &lt;/div&gt;  )}function App() {  const NewComponent = HOC(Component1)  return (    &lt;div&gt;      &lt;NewComponent /&gt;    &lt;/div&gt;  )}</code></pre><h4 id="Refs不会被传递"><a href="#Refs不会被传递" class="headerlink" title="Refs不会被传递"></a>Refs不会被传递</h4><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p><p><strong>解决方案</strong><br><code>React.forwardRef</code></p><pre><code class="js">const FancyButton = React.forwardRef((props, ref) =&gt; (  &lt;button ref={ref} className=&quot;FancyButton&quot;&gt;    {props.children}  &lt;/button&gt;));</code></pre><h4 id="抽象state"><a href="#抽象state" class="headerlink" title="抽象state"></a>抽象state</h4><p>我们通常将被包裹的组件的状态提到包裹它的组件中，通常指受控和非受控组件</p><pre><code class="js">// React Redux 的 `connect` 函数const ConnectedComment = connect(commentSelector, commentActions)(CommentList);</code></pre><p>等价于</p><pre><code class="js">// connect 是一个函数，它的返回值为另外一个函数。const enhance = connect(commentListSelector, commentListActions);// 返回值为 HOC，它会返回已经连接 Redux store 的组件const ConnectedComment = enhance(CommentList);</code></pre><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><pre><code class="js">function iiHOC(WrappedComponent) {  return class Enhancer extends WrappedComponent {    render() {      return super.render()      // super 调用父组件原型上的方法    }  }}</code></pre><h3 id="操作state"><a href="#操作state" class="headerlink" title="操作state"></a>操作state</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React--错误边界组件</title>
      <link href="undefined2019/09/04/React-%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%E7%BB%84%E4%BB%B6/"/>
      <url>2019/09/04/React-%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h1><p>错误边界是一种React组件，这种组件可以捕获并打印起自组件树任何位置的javascript错误，并且会渲染备用ui组件<code>只有 class 组件才可以成为成错误边界组件</code>,通常也只需要声明一次错误组件，并在整个项目中去使用</p><p><strong>例如：</strong> 将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样</p><blockquote><p><strong>注意</strong>:错误边界无法捕获以下场景中产生的错误：</p><ul><li>事件处理（render 方法和生命周期方法不同，事件处理器不会在渲染期间触发，一般都是自己在事件函数中通过try catch 进行错误捕获）</li><li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</li><li>服务端渲染</li><li>它自身抛出来的错误（并非它的子组件）</li></ul></blockquote><h2 id="错误边界组件"><a href="#错误边界组件" class="headerlink" title="错误边界组件"></a>错误边界组件</h2><ul><li><code>static getDerivedStateFromError()</code> // 函数内部return出新的state值</li><li><code>componentDidCatch</code> // 将错误日志上报浏览器</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;class ErrorBoundary extends React.Component {  constructor(props) {    super(props)    this.state = { error: null, errorInfo: null }  }  static getDerivedStateFromError(error) {    return { error }  }  componentDidCatch(error, errorInfo) {    this.setState({      error,      errorInfo,      use: false,    })  }  render() {    const { errorInfo, error } = this.state    const { children } = this.props    if (errorInfo) {      // Error path      return (        &lt;div&gt;          &lt;h2&gt;Something went wrong.&lt;/h2&gt;          &lt;details style={{ whiteSpace: 'pre-wrap' }}&gt;            {error &amp;&amp; error.toString()}            &lt;br /&gt;            {errorInfo.componentStack}          &lt;/details&gt;        &lt;/div&gt;      )    }    return children  }}class BuggyCounter extends React.Component {  constructor(props) {    super(props)    this.state = { counter: 0 }  }  handleClick = () =&gt; {    this.setState(({ counter }) =&gt; ({      counter: counter + 1,    }))  }  render() {    const { counter } = this.state    if (counter === 5) {      throw new Error(&#39;I crashed!&#39;)    }    return &lt;h1 onClick={this.handleClick}&gt;{counter}&lt;/h1&gt;  }}function App() {  return (    &lt;div&gt;      &lt;ErrorBoundary&gt;        &lt;BuggyCounter /&gt;      &lt;/ErrorBoundary&gt;    &lt;/div&gt;  )}ReactDOM.render(  &lt;App /&gt;,  document.getElementById(&#39;root&#39;),)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Context</title>
      <link href="undefined2019/09/03/context/"/>
      <url>2019/09/03/context/</url>
      
        <content type="html"><![CDATA[<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据,很多不同层级的组件需要访问同样一些的数据，使用时需要考虑清楚，不然会使组件的复用性变差</p><pre><code class="js">// React.createContextconst MyContext = React.createContext(defaultValue); // 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效&lt;MyContext.Provider value={/* 某个值 */} /&gt;// Provider新旧值检测来确定变化，使用了与 Object.is 相同的算法// Context.contextTypeclass MyClass extends React.Component {  componentDidMount() {    let value = this.context;    /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */  }  componentDidUpdate() {    let value = this.context;    /* ... */  }  componentWillUnmount() {    let value = this.context;    /* ... */  }  render() {    let value = this.context;    /* 基于 MyContext 组件的值进行渲染 */  }}MyClass.contextType = MyContext;// 两种处理方法class MyClass extends React.Component {  static contextType = MyContext  componentDidMount() {    let value = this.context;    /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */  }  componentDidUpdate() {    let value = this.context;    /* ... */  }  componentWillUnmount() {    let value = this.context;    /* ... */  }  render() {    let value = this.context;    /* 基于 MyContext 组件的值进行渲染 */  }}// 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值// Context.Consumer&lt;MyContext.Consumer&gt;  {value =&gt; /* 基于 context 值进行渲染*/}&lt;/MyContext.Consumer&gt;// 这需要函数作为子元素（function as a child）这种做法。这个函数接收当前的 context 值，返回一个 React 节点。</code></pre><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;const ThemeContext = React.createContext(&#39;light&#39;)class Nav extends React.Component {  state = {}  // context 可以在每个生命周期的钩子里拿到  static contextType = ThemeContext // 两种方法，可以在类上直接添加该属性，也可以使用static  componentDidMount() {    console.log(this.context)  }  render() {    return (      &lt;div&gt;nav:我是nav&lt;/div&gt;    )  }}function Container() {  return (    &lt;div&gt;      &lt;Nav /&gt;      &lt;br /&gt;      &lt;Content /&gt;    &lt;/div&gt;  )}function Content() {  return (    &lt;ThemeContext.Consumer&gt;      {value =&gt; (        &lt;div&gt;{value}&lt;/div&gt;      )}    &lt;/ThemeContext.Consumer&gt;  )}const App = () =&gt; {  return (    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;      &lt;Container /&gt;    &lt;/ThemeContext.Provider&gt;  )}export default () =&gt; {  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))}</code></pre><h2 id="16-8-useContext"><a href="#16-8-useContext" class="headerlink" title="16.8 useContext"></a>16.8 useContext</h2><pre><code class="js">const value = useContext(MyContext);</code></pre><p><code>useContext</code> 的参数必须是 <code>context</code> 对象本身：</p><ul><li>正确： <code>useContext(MyContext)</code></li><li>错误： <code>useContext(MyContext.Consumer)</code></li><li>错误： <code>useContext(MyContext.Provider)</code></li></ul><p><em><code>useContext(MyContext)</code> 相当于 <code>class 组件中的 static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code></em></p><p><strong>注意</strong>： 调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，考虑使用React.memo进行优化</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>冰总头条面经</title>
      <link href="undefined2019/09/01/%E5%86%B0%E6%80%BB%E5%A4%B4%E6%9D%A1%E9%9D%A2%E7%BB%8F/"/>
      <url>2019/09/01/%E5%86%B0%E6%80%BB%E5%A4%B4%E6%9D%A1%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="冰总头条面经"><a href="#冰总头条面经" class="headerlink" title="冰总头条面经"></a>冰总头条面经</h1><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><h2 id="css拖动窗口-gt-宽度和高度保持比例"><a href="#css拖动窗口-gt-宽度和高度保持比例" class="headerlink" title="css拖动窗口 ===&gt; 宽度和高度保持比例"></a>css拖动窗口 ===&gt; 宽度和高度保持比例</h2><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><h2 id="面向过程-面向对象"><a href="#面向过程-面向对象" class="headerlink" title="面向过程+面向对象"></a>面向过程+面向对象</h2><h2 id="弱类型-强类型"><a href="#弱类型-强类型" class="headerlink" title="弱类型 + 强类型"></a>弱类型 + 强类型</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换  [] == ![]"></a>类型转换  [] == ![]</h2><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h2 id="event-emit"><a href="#event-emit" class="headerlink" title="event emit"></a>event emit</h2><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h2 id="vue-React"><a href="#vue-React" class="headerlink" title="vue + React"></a>vue + React</h2><h2 id="浏览器刷新频率-时间分片"><a href="#浏览器刷新频率-时间分片" class="headerlink" title="浏览器刷新频率(时间分片)"></a>浏览器刷新频率(时间分片)</h2><h2 id="js在V8的执行过程"><a href="#js在V8的执行过程" class="headerlink" title="js在V8的执行过程"></a>js在V8的执行过程</h2><h2 id="Model-组件手撕"><a href="#Model-组件手撕" class="headerlink" title="Model 组件手撕"></a>Model 组件手撕</h2><h2 id="wasm"><a href="#wasm" class="headerlink" title="wasm"></a>wasm</h2><h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><h2 id="稀疏数组与普通数组的区别"><a href="#稀疏数组与普通数组的区别" class="headerlink" title="稀疏数组与普通数组的区别"></a>稀疏数组与普通数组的区别</h2><h2 id="htmlCollection-和普通数组的区别"><a href="#htmlCollection-和普通数组的区别" class="headerlink" title="htmlCollection 和普通数组的区别"></a>htmlCollection 和普通数组的区别</h2><h2 id="querySelector-与普通Dom选择器"><a href="#querySelector-与普通Dom选择器" class="headerlink" title="querySelector 与普通Dom选择器"></a>querySelector 与普通Dom选择器</h2><h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="undefined2019/08/28/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>2019/08/28/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="一等公民的函数"><a href="#一等公民的函数" class="headerlink" title="一等公民的函数"></a>一等公民的函数</h2><p>减少包裹，删减无用代码</p><pre><code class="js">// 这行ajaxCall(json =&gt; callback(json));// 等价于这行ajaxCall(callback);</code></pre><h2 id="纯函数的好处"><a href="#纯函数的好处" class="headerlink" title="纯函数的好处"></a>纯函数的好处</h2><p>从定义上来说，纯函数必须要能够根据相同的输入返回相同的输出；如果函数需要跟外部事物打交道，那么就无法保证这一点了。</p><h3 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h3><pre><code class="js">var squareNumber  = memoize(function(x){ return x*x; });squareNumber(4);//=&gt; 16squareNumber(4); // 从缓存中读取输入值为 4 的结果//=&gt; 16squareNumber(5);//=&gt; 25squareNumber(5); // 从缓存中读取输入值为 5 的结果//=&gt; 25</code></pre><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><pre><code class="js">var signUp = function(attrs) {  var user = saveUser(attrs);  welcomeUser(user);};var saveUser = function(attrs) {    var user = Db.save(attrs);    ...};var welcomeUser = function(user) {    Email(user, ...);    ...};// 纯的var signUp = function(Db, Email, attrs) {  return function() {    var user = saveUser(Db, attrs);    welcomeUser(Email, user);  };};var saveUser = function(Db, attrs) {    ...};var welcomeUser = function(Email, user) {    ...};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="undefined2019/08/24/hello-world/"/>
      <url>2019/08/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>